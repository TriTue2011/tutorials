blueprint:
  name: Device Timer Plus
  author: luuquangvu
  description: >
    Multi-timer using per-key cache via Pyscript.
    Modes: start / cancel / extend / pause / resume / list.
    - Each timer is stored under its own key: voice_timer:<id> (with individual TTL = remaining + buffer)
    - Index of all timer IDs: voice_timer_index (auto-compacted on start/list)
    - De-duplication: cancel_existing | reuse_existing | error | none; match by: entity | actions | both
  domain: script
  homeassistant:
    min_version: 2024.10.0
  input:
    # De-duplication
    dedupe_mode:
      name: Dedupe mode
      description: cancel_existing | reuse_existing | error | none
      default: cancel_existing
      selector:
        select:
          options: [cancel_existing, reuse_existing, error, none]
    dedupe_match:
      name: Dedupe match by
      description: entity | actions | both
      default: both
      selector:
        select:
          options: [entity, actions, both]

    # Registry keys & TTL
    registry_index_key:
      name: Index Key
      default: voice_timer_index
      selector:
        text:
    registry_timer_prefix:
      name: Timer Key Prefix
      default: "voice_timer:"
      selector:
        text:
    ttl_buffer_seconds:
      name: TTL buffer (seconds)
      description: Added to remaining when setting per-timer TTL
      default: 60
      selector:
        number:
          min: 60
          max: 3600
          unit_of_measurement: s
          mode: box

mode: parallel
max: 200

fields:
  mode:
    name: Mode
    required: true
    selector:
      select:
        options: [start, cancel, extend, pause, resume, list]

  # Identification
  timer_id:
    name: Timer ID
    description: Leave empty on start to auto-generate from entity_id + timestamp
    selector:
      text:
  target_entity:
    name: Target Entity
    description: Device entity_id used for identification and de-duplication
    selector:
      text:

  # Start
  duration_seconds:
    name: Duration (seconds) on START
    selector:
      number:
        min: 1
        max: 604800
        unit_of_measurement: s
        mode: box
  expire_actions:
    name: Actions on expire
    description: Runs when timer completes (stored for resume after pause)
    selector:
      action: {}

  # Extend / Pause / Resume
  extend_seconds:
    name: Seconds to extend (EXTEND)
    selector:
      number:
        min: 1
        max: 604800
        unit_of_measurement: s
        mode: box

    # List
  list_entity_filter:
    name: Filter list by entity (optional)
    selector:
      text:

sequence:
  - variables:
      _mode: "{{ mode }}"
      _tid_in: "{{ timer_id }}"
      _entity_norm: "{{ target_entity | string | trim | lower }}"
      _dur: "{{ duration_seconds }}"
      _expire_actions_in: "{{ expire_actions }}"
      _ext: "{{ extend_seconds }}"
      _filter: "{{ list_entity_filter }}"
      _dedupe_mode: !input dedupe_mode
      _dedupe_match: !input dedupe_match
      _index_key: !input registry_index_key
      _prefix: !input registry_timer_prefix
      _buf: !input ttl_buffer_seconds

  # Read & compact index -> _IDX_ALIVE
  - action: pyscript.memory_cache_get
    data: { key: "{{ _index_key }}" }
    response_variable: _idx_res
  - variables:
      _IDX_LIST: >
        {% set idx_raw = _idx_res.value if _idx_res.status == 'ok' else [] %}
        {% if idx_raw is sequence %}
          {{ idx_raw }}
        {% else %}
          {{ [] }}
        {% endif %}
      _IDX_COUNT: "{{ _IDX_LIST | length if _IDX_LIST is sequence else 0 }}"
      _IDX_ALIVE: []
  - repeat:
      for_each: "{{ _IDX_LIST if _IDX_LIST is sequence else [] }}"
      sequence:
        - action: pyscript.memory_cache_get
          data: { key: "{{ _prefix }}{{ repeat.item }}" }
          response_variable: _tr
        - choose:
            - conditions: "{{ _tr.status == 'ok' }}"
              sequence:
                - variables:
                    _IDX_ALIVE: >
                      {% set current = (_IDX_ALIVE | list) if _IDX_ALIVE is sequence else [] %}
                      {% set ns = namespace(out=[]) %}
                      {% for existing in current %}
                        {% if existing not in ns.out %}
                          {% set ns.out = ns.out + [existing] %}
                        {% endif %}
                      {% endfor %}
                      {% if repeat.item not in ns.out %}
                        {% set ns.out = ns.out + [repeat.item] %}
                      {% endif %}
                      {{ ns.out }}
  - variables:
      _IDX_STALE: >
        {% set stale = [] %}
        {% set alive = _IDX_ALIVE if _IDX_ALIVE is sequence else [] %}
        {% set idx_list = _IDX_LIST if _IDX_LIST is sequence else [] %}
        {% for existing in idx_list %}
          {% if existing not in alive %}
            {% set stale = stale + [existing] %}
          {% endif %}
        {% endfor %}
        {{ stale }}
  - action: pyscript.memory_cache_get
    data: { key: "{{ _index_key }}" }
    response_variable: _idx_latest_compact
  - variables:
      _IDX_LATEST_COMPACT: >
        {% set idx_raw = _idx_latest_compact.value if _idx_latest_compact.status == 'ok' else [] %}
        {% if idx_raw is sequence %}
          {{ idx_raw }}
        {% else %}
          {{ [] }}
        {% endif %}
      _IDX_COMPACTED: >
        {% set stale = _IDX_STALE if _IDX_STALE is sequence else [] %}
        {% set current_alive = _IDX_ALIVE if _IDX_ALIVE is sequence else [] %}
        {% set ns = namespace(out=[]) %}
        {% set compact = _IDX_LATEST_COMPACT if _IDX_LATEST_COMPACT is iterable else [] %}
        {% for existing in compact %}
          {% if existing not in stale and existing not in ns.out %}
            {% set ns.out = ns.out + [existing] %}
          {% endif %}
        {% endfor %}
        {% for existing in current_alive %}
          {% if existing not in stale and existing not in ns.out %}
            {% set ns.out = ns.out + [existing] %}
          {% endif %}
        {% endfor %}
        {{ ns.out }}
      _IDX_ALIVE: "{{ _IDX_COMPACTED if _IDX_COMPACTED is sequence else [] }}"
  - action: pyscript.memory_cache_set
    data:
      key: "{{ _index_key }}"
      value: "{{ _IDX_ALIVE }}"
      ttl_seconds: 2592000  # 30 days
    response_variable: cache_set_index

  # Gather active timers for dedupe checks
  - variables:
      _ACTIVE: []
  - repeat:
      for_each: "{{ _IDX_ALIVE if _IDX_ALIVE is sequence else [] }}"
      sequence:
        - action: pyscript.memory_cache_get
          data: { key: "{{ _prefix }}{{ repeat.item }}" }
          response_variable: _ar
        - variables:
            _ar_data: "{{ _ar.value | default({}) if _ar.status == 'ok' else {} }}"
        - choose:
            - conditions: "{{ _ar.status == 'ok' and (_ar_data.status|string|lower) in ['running','paused'] }}"
              sequence:
                - variables:
                    _ACTIVE_ITEM: >
                      {% set raw_entity = _ar_data.entity_id | default('') %}
                      {% set entity = raw_entity|string|trim|lower %}
                      {% set raw_actions = _ar_data.actions if _ar_data.actions is defined else [] %}
                      {% if raw_actions is mapping %}
                        {% set raw_actions = [raw_actions] %}
                      {% elif raw_actions is none %}
                        {% set raw_actions = [] %}
                      {% endif %}
                      {% set ns_actions = namespace(out=[]) %}
                      {% for step in raw_actions %}
                        {% set svc = step.action | default('') %}
                        {% if svc is string and svc|length > 0 %}
                          {% set normalized = {
                            'action': svc,
                            'target': {'entity_id': entity},
                            'data': step.data | default({})
                          } %}
                          {% set ns_actions.out = ns_actions.out + [normalized] %}
                        {% endif %}
                      {% endfor %}
                      {% set actions = ns_actions.out %}
                      {{ dict(_ar_data, **{
                        'entity_id': entity,
                        'actions': actions
                      }) }}
                    _ACTIVE: >
                      {% set current = (_ACTIVE | list) if _ACTIVE is sequence else [] %}
                      {{ current + [_ACTIVE_ITEM] }}

  - choose:

      #######################################################################
      # START
      #######################################################################
      - conditions: "{{ _mode == 'start' }}"
        sequence:
          - variables:
              _IDX_DEDUPE_REMOVALS: []
          # Dedupe checks
          - variables:
              _same_entity: >-
                {% if _entity_norm|length == 0 %}
                  false
                {% else %}
                  {% set ns = namespace(match=false) %}
                  {% set active = _ACTIVE if _ACTIVE is sequence else [] %}
                  {% for item in active %}
                    {% set eid = item.entity_id | default('') | string | trim | lower %}
                    {% if eid == _entity_norm %}
                      {% set ns.match = true %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.match }}
                {% endif %}
              _new_actions: >
                {% set raw = _expire_actions_in | default([]) %}
                {% if raw is mapping %}
                  {% set raw = [raw] %}
                {% elif raw is none %}
                  {% set raw = [] %}
                {% endif %}
                {% set ns = namespace(out=[]) %}
                {% for step in raw %}
                  {% set svc = step.action | default('') %}
                  {% if svc is string and svc|length > 0 %}
                    {% set normalized = {
                      'action': svc,
                      'target': {'entity_id': _entity_norm},
                      'data': step.data | default({})
                    } %}
                    {% set ns.out = ns.out + [normalized] %}
                  {% endif %}
                {% endfor %}
                {{ ns.out }}
              _same_actions: >-
                {% if _new_actions | count == 0 %}
                  false
                {% else %}
                  {% set ns = namespace(match=false) %}
                  {% set active = _ACTIVE if _ACTIVE is sequence else [] %}
                  {% for item in active %}
                    {% if (item.actions | default([])) == _new_actions %}
                      {% set ns.match = true %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.match }}
                {% endif %}
              _is_dup: >-
                {% if _dedupe_match == 'entity' %}
                  {{ _same_entity }}
                {% elif _dedupe_match == 'actions' %}
                  {{ _same_actions }}
                {% else %}
                  {{ _same_entity and _same_actions }}
                {% endif %}

          - choose:
              # A) cancel_existing - cancel matching older timers
              - conditions: "{{ _dedupe_mode == 'cancel_existing' and _is_dup }}"
                sequence:
                  - repeat:
                      for_each: "{{ _ACTIVE if _ACTIVE is sequence else [] }}"
                      sequence:
                        - variables:
                            _match_entity: "{{ (repeat.item.entity_id | default('') | string | trim | lower) == _entity_norm }}"
                            _match_actions: "{{ (repeat.item.actions | default([])) == _new_actions }}"
                        - choose:
                            - conditions: >-
                                {% if _dedupe_match == 'entity' %}
                                  {{ _match_entity }}
                                {% elif _dedupe_match == 'actions' %}
                                  {{ _match_actions }}
                                {% else %}
                                  {{ _match_entity and _match_actions }}
                                {% endif %}
                              sequence:
                                - event: device_timer_signal
                                  event_data: { timer_id: "{{ repeat.item.id }}", reason: "cancel" }
                                - action: pyscript.memory_cache_set
                                  data:
                                    key: "{{ _prefix }}{{ repeat.item.id }}"
                                    value: >
                                      {{ dict(repeat.item, **{'status':'canceled','canceled_at': now().isoformat()}) }}
                                    ttl_seconds: "{{ _buf|int }}"
                                  response_variable: cache_set_timer_id
                                - variables:
                                    _IDX_ALIVE: >
                                      {% set alive = _IDX_ALIVE if _IDX_ALIVE is sequence else [] %}
                                      {% set ns = namespace(out=[]) %}
                                      {% for existing in alive %}
                                        {% if existing != repeat.item.id and existing not in ns.out %}
                                          {% set ns.out = ns.out + [existing] %}
                                        {% endif %}
                                      {% endfor %}
                                      {{ ns.out }}
                                    _ACTIVE: >
                                      {% set items = _ACTIVE if _ACTIVE is sequence else [] %}
                                      {% set ns_items = namespace(out=[]) %}
                                      {% for t in items %}
                                        {% if t.id != repeat.item.id %}
                                          {% set ns_items.out = ns_items.out + [t] %}
                                        {% endif %}
                                      {% endfor %}
                                      {{ ns_items.out }}
                                    _IDX_DEDUPE_REMOVALS: >
                                      {% set removed = (_IDX_DEDUPE_REMOVALS | list) if _IDX_DEDUPE_REMOVALS is sequence else [] %}
                                      {% if repeat.item.id not in removed %}
                                        {% set removed = removed + [repeat.item.id] %}
                                      {% endif %}
                                      {{ removed }}

              # B) reuse_existing - do not create a new one
              - conditions: "{{ _dedupe_mode == 'reuse_existing' and _is_dup }}"
                sequence:
                  - stop: "reuse_existing: skip creating new timer"

              # C) error - notify and stop
              - conditions: "{{ _dedupe_mode == 'error' and _is_dup }}"
                sequence:
                  - action: notify.persistent_notification
                    data:
                      title: "Device Timer"
                      message: "âŒ Duplicate timer ({{ _dedupe_match }}). Cancel or rename before creating a new one."
                  - stop: "dup_error"

          - action: pyscript.memory_cache_get
            data: { key: "{{ _index_key }}" }
            response_variable: _idx_latest_start
          - variables:
              _IDX_LATEST_START: >
                {% set idx_raw = _idx_latest_start.value if _idx_latest_start.status == 'ok' else [] %}
                {% if idx_raw is sequence %}
                  {{ idx_raw }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _IDX_ALIVE_PRE: "{{ _IDX_ALIVE if _IDX_ALIVE is sequence else [] }}"
              _IDX_ALIVE: >
                {% set removed = _IDX_DEDUPE_REMOVALS if _IDX_DEDUPE_REMOVALS is sequence else [] %}
                {% set ns = namespace(out=[]) %}
                {% set latest = _IDX_LATEST_START if _IDX_LATEST_START is sequence else [] %}
                {% for existing in latest %}
                  {% if existing not in removed and existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {% for existing in _IDX_ALIVE_PRE %}
                  {% if existing not in removed and existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {{ ns.out }}
              _IDX_DEDUPE_REMOVALS: "[]"
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _index_key }}"
              value: "{{ _IDX_ALIVE }}"
              ttl_seconds: 2592000
            response_variable: cache_set_index

          # Create id + persist per-timer
          - condition: template
            value_template: "{{ _dur|int > 0 }}"
          - variables:
              _id: >-
                {% if _tid_in|length > 0 %}{{ _tid_in }}
                {% else %}{{ (_entity_norm|default('timer')|lower|regex_replace('[^a-z0-9]+','_')) ~ '__' ~ (as_timestamp(now())|int) }}
                {% endif %}
              _end_dt: "{{ now() + timedelta(seconds=_dur|int) }}"
              _end_iso: "{{ as_datetime(_end_dt).isoformat() }}"
              _item: >
                {{ dict(
                  id=_id,
                  entity_id=_entity_norm,
                  status='running',
                  created_at=now().isoformat(),
                  end=_end_iso,
                  remaining=_dur|int,
                  actions=_new_actions

                ) }}
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id }}"
              value: "{{ _item }}"
              ttl_seconds: "{{ (_dur|int) + (_buf|int) }}"
            response_variable: cache_set_timer_id

          # Update index (append id if missing)
          - variables:
              _IDX_ALIVE_PRE: "{{ _IDX_ALIVE if _IDX_ALIVE is sequence else [] }}"
              _IDX_ALIVE: >
                {% set ns = namespace(out=[]) %}
                {% for existing in _IDX_ALIVE_PRE %}
                  {% if existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {% if _id not in ns.out %}
                  {% set ns.out = ns.out + [_id] %}
                {% endif %}
                {{ ns.out }}
          - action: pyscript.memory_cache_get
            data: { key: "{{ _index_key }}" }
            response_variable: _idx_latest_append
          - variables:
              _IDX_LATEST_APPEND: >
                {% set idx_raw = _idx_latest_append.value if _idx_latest_append.status == 'ok' else [] %}
                {% if idx_raw is sequence %}
                  {{ idx_raw }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _IDX3: >
                {% set ns = namespace(out=[]) %}
                {% set append_list = _IDX_LATEST_APPEND if _IDX_LATEST_APPEND is sequence else [] %}
                {% for existing in append_list %}
                  {% if existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {% set alive = _IDX_ALIVE if _IDX_ALIVE is sequence else [] %}
                {% for existing in alive %}
                  {% if existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {{ ns.out }}
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _index_key }}"
              value: "{{ _IDX3 }}"
              ttl_seconds: 2592000
            response_variable: cache_set_index

          # Wait for expire or cancel/pause signals
          - wait_for_trigger:
              - trigger: template
                value_template: "{{ now() >= as_datetime(_end_iso) }}"
              - trigger: event
                event_type: device_timer_signal
                event_data: { timer_id: "{{ _id }}" }
            timeout: "{{ (as_datetime(_end_iso) - now()).total_seconds()|int + 5 }}"
            continue_on_timeout: true
          - variables:
              _wait_is_event: "{{ wait.trigger is not none and wait.trigger.platform == 'event' }}"
              _wait_reason: "{{ wait.trigger.event.data.reason | default('cancel') if wait.trigger is not none and wait.trigger.platform == 'event' else '' }}"

          # React to external signals
          - choose:
              - conditions: "{{ _wait_is_event and (_wait_reason | lower) == 'pause' }}"
                sequence:
                  - stop: "paused_wait"
              - conditions: "{{ _wait_is_event }}"
                sequence:
                  # Remove from index
                  - action: pyscript.memory_cache_get
                    data: { key: "{{ _index_key }}" }
                    response_variable: _idx_cancel_event
                  - variables:
                      _IDX_CANCEL_EVENT: >
                        {% set idx_raw = _idx_cancel_event.value if _idx_cancel_event.status == 'ok' else [] %}
                        {% if idx_raw is sequence %}
                          {{ idx_raw }}
                        {% else %}
                          {{ [] }}
                        {% endif %}
                      _IDX5: >
                        {% set ns = namespace(out=[]) %}
                        {% set cancel_list = _IDX_CANCEL_EVENT if _IDX_CANCEL_EVENT is sequence else [] %}
                        {% for existing in cancel_list %}
                          {% if existing != _id and existing not in ns.out %}
                            {% set ns.out = ns.out + [existing] %}
                          {% endif %}
                        {% endfor %}
                        {{ ns.out }}
                      _IDX_ALIVE: "{{ _IDX5 if _IDX5 is sequence else [] }}"
                  - action: pyscript.memory_cache_set
                    data:
                      key: "{{ _index_key }}"
                      value: "{{ _IDX5 if _IDX5 is sequence else [] }}"
                      ttl_seconds: 2592000
                    response_variable: cache_set_index
                  # Mark canceled + short TTL
                  - action: pyscript.memory_cache_set
                    data:
                      key: "{{ _prefix }}{{ _id }}"
                      value: >
                        {{ dict(_item, **{'status':'canceled','canceled_at': now().isoformat()}) }}
                      ttl_seconds: "{{ _buf|int }}"
                    response_variable: cache_set_timer_id
                  - stop: "canceled_wait"

          # Expired: run action (if any) + mark expired + remove from index
          - variables:
              _run_actions: "{{ (_item.actions | default([])) | selectattr('action','defined') | list }}"
          - choose:
              - conditions: "{{ _run_actions | count > 0 }}"
                sequence:
                  - repeat:
                      for_each: "{{ _run_actions }}"
                      sequence:
                        - action: "{{ repeat.item.action }}"
                          target: "{{ repeat.item.target | default({}) }}"
                          data: "{{ repeat.item.data | default({}) }}"
          - action: pyscript.memory_cache_get
            data: { key: "{{ _index_key }}" }
            response_variable: _idx_expired_event
          - variables:
              _IDX_EXPIRED_EVENT: >
                {% set idx_raw = _idx_expired_event.value if _idx_expired_event.status == 'ok' else [] %}
                {% if idx_raw is sequence %}
                  {{ idx_raw }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _IDX7: >
                {% set ns = namespace(out=[]) %}
                {% set expired_list = _IDX_EXPIRED_EVENT if _IDX_EXPIRED_EVENT is sequence else [] %}
                {% for existing in expired_list %}
                  {% if existing != _id and existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {{ ns.out }}
              _IDX_ALIVE: "{{ _IDX7 if _IDX7 is sequence else [] }}"
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _index_key }}"
              value: "{{ _IDX7 if _IDX7 is sequence else [] }}"
              ttl_seconds: 2592000
            response_variable: cache_set_index
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id }}"
              value: >
                {{ dict(_item, **{'status':'expired','expired_at': now().isoformat(),'remaining':0}) }}
              ttl_seconds: "{{ _buf|int }}"
            response_variable: cache_set_timer_id

      #######################################################################
      # CANCEL (by id or latest by entity)
      #######################################################################
      - conditions: "{{ _mode == 'cancel' }}"
        sequence:
          - variables:
              _cancel_candidates: >
                {% if _entity_norm|length > 0 %}
                  {% set active = _ACTIVE if _ACTIVE is sequence else [] %}
                  {{ active | selectattr('entity_id', 'equalto', _entity_norm) | list }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _cancel_latest: "{{ (_cancel_candidates | sort(attribute='created_at'))[-1] if _cancel_candidates|count>0 else none }}"
              _id_resolved: >
                {{ _tid_in if _tid_in|length > 0 else (_cancel_latest.id if _cancel_latest is mapping else '') }}
          - condition: template
            value_template: "{{ _id_resolved|length > 0 }}"
          - action: pyscript.memory_cache_get
            data: { key: "{{ _prefix }}{{ _id_resolved }}" }
            response_variable: _cancel_timer
          - variables:
              _cancel_timer_data: "{{ _cancel_timer.value | default({}) if _cancel_timer.status == 'ok' else {} }}"
              _T: "{{ _cancel_timer_data if _cancel_timer.status == 'ok' else {'id': _id_resolved} }}"
              _cancel_remaining: >-
                {% if _cancel_timer.status == 'ok' %}
                  {% if (_T.status|string|lower) == 'running' and (_T.end is defined) %}
                    {{ (as_timestamp(as_datetime(_T.end)) - as_timestamp(now())) | int(0) }}
                  {% else %}
                    {{ _T.remaining|default(0)|int(0) }}
                  {% endif %}
                {% else %}
                  0
                {% endif %}
              _T2: >
                {{ dict(_T, **{'remaining': (_cancel_remaining if _cancel_remaining > 0 else 0)}) }}
          # Remove from index
          - action: pyscript.memory_cache_get
            data: { key: "{{ _index_key }}" }
            response_variable: _idx_cancel_mode
          - variables:
              _IDX_CANCEL_MODE: >
                {% set idx_raw = _idx_cancel_mode.value if _idx_cancel_mode.status == 'ok' else [] %}
                {% if idx_raw is sequence %}
                  {{ idx_raw }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _IDX3: >
                {% set ns = namespace(out=[]) %}
                {% set cancel_mode = _IDX_CANCEL_MODE if _IDX_CANCEL_MODE is sequence else [] %}
                {% for existing in cancel_mode %}
                  {% if existing != _id_resolved and existing not in ns.out %}
                    {% set ns.out = ns.out + [existing] %}
                  {% endif %}
                {% endfor %}
                {{ ns.out }}
              _IDX_ALIVE: "{{ _IDX3 if _IDX3 is sequence else [] }}"
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _index_key }}"
              value: "{{ _IDX3 if _IDX3 is sequence else [] }}"
              ttl_seconds: 2592000
            response_variable: cache_set_index
          # Mark canceled + short TTL
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id_resolved }}"
              value: >
                {{ dict(_T2, **{'status':'canceled','canceled_at':now().isoformat()}) }}
              ttl_seconds: "{{ _buf|int }}"
            response_variable: cache_set_timer_id
          # Notify running instance to stop
          - event: device_timer_signal
            event_data: { timer_id: "{{ _id_resolved }}", reason: "cancel" }

      #######################################################################
      # EXTEND (+N seconds)
      #######################################################################
      - conditions: "{{ _mode == 'extend' }}"
        sequence:
          - variables:
              _extend_candidates: >
                {% if _entity_norm|length > 0 %}
                  {% set active = _ACTIVE if _ACTIVE is sequence else [] %}
                  {{ active | selectattr('entity_id', 'equalto', _entity_norm) | list }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _extend_latest: "{{ (_extend_candidates | sort(attribute='created_at'))[-1] if _extend_candidates|count>0 else none }}"
              _id_resolved: >
                {{ _tid_in if _tid_in|length > 0 else (_extend_latest.id if _extend_latest is mapping else '') }}
          - condition: template
            value_template: "{{ _id_resolved|length > 0 }}"
          - action: pyscript.memory_cache_get
            data: { key: "{{ _prefix }}{{ _id_resolved }}" }
            response_variable: _tres
          - variables:
              _tres_data: "{{ _tres.value | default({}) if _tres.status == 'ok' else {} }}"
          - condition: template
            value_template: "{{ _tres.status == 'ok' and (_tres_data.status|string|lower) in ['running','paused'] }}"
          - variables:
              _T: "{{ _tres_data }}"
              _new_end: >-
                {% if (_T.status|string|lower) == 'running' %}
                  {{ (as_datetime(_T.end | default(now())) + timedelta(seconds=_ext|int)).isoformat() }}
                {% elif (_T.status|string|lower) == 'paused' %}
                  {{ (now() + timedelta(seconds=(_T.remaining|int + _ext|int))).isoformat() }}
                {% else %}
                  {{ _T.end }}
                {% endif %}
              _new_remaining: >-
                {% if (_T.status|string|lower) == 'running' %}
                  {% set delta = (as_timestamp(as_datetime(_new_end)) - as_timestamp(now())) | int %}
                {% elif (_T.status|string|lower) == 'paused' %}
                  {% set delta = (_T.remaining|int(0) + _ext|int(0)) %}
                {% else %}
                  {% set delta = _T.remaining|int(0) %}
                {% endif %}
                {{ delta if delta > 0 else 0 }}
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id_resolved }}"
              value: >
                {{ dict(_T, **{'end': _new_end, 'remaining': _new_remaining}) }}
              ttl_seconds: "{{ (_new_remaining|int) + (_buf|int) }}"
            response_variable: cache_set_timer_id

      #######################################################################
      # PAUSE
      #######################################################################
      - conditions: "{{ _mode == 'pause' }}"
        sequence:
          - variables:
              _pause_candidates: >
                {% if _entity_norm|length > 0 %}
                  {% set active = _ACTIVE if _ACTIVE is sequence else [] %}
                  {{ active | selectattr('entity_id', 'equalto', _entity_norm) | list }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _pause_latest: "{{ (_pause_candidates | sort(attribute='created_at'))[-1] if _pause_candidates|count>0 else none }}"
              _id_resolved: >
                {{ _tid_in if _tid_in|length > 0 else (_pause_latest.id if _pause_latest is mapping else '') }}
          - condition: template
            value_template: "{{ _id_resolved|length > 0 }}"
          - action: pyscript.memory_cache_get
            data: { key: "{{ _prefix }}{{ _id_resolved }}" }
            response_variable: _tres
          - variables:
              _tres_data: "{{ _tres.value | default({}) if _tres.status == 'ok' else {} }}"
          - condition: template
            value_template: "{{ _tres.status == 'ok' and (_tres_data.status|string|lower) == 'running' }}"
          - variables:
              _T: "{{ _tres_data }}"
              _remain: "{{ (as_timestamp(as_datetime(_T.end | default(now()))) - as_timestamp(now())) | int }}"
              _remain2: "{{ iif(_remain>0, _remain, 0) }}"
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id_resolved }}"
              value: >
                {{ dict(_T, **{'status':'paused','paused_at':now().isoformat(),'remaining': _remain2}) }}
              ttl_seconds: "{{ (_remain2|int) + (_buf|int) }}"
            response_variable: cache_set_timer_id
          - event: device_timer_signal
            event_data: { timer_id: "{{ _id_resolved }}", reason: "pause" }

      #######################################################################
      # RESUME
      #######################################################################
      - conditions: "{{ _mode == 'resume' }}"
        sequence:
          - variables:
              _resume_candidates: >
                {% if _entity_norm|length > 0 %}
                  {% set active = _ACTIVE if _ACTIVE is sequence else [] %}
                  {{ active | selectattr('entity_id', 'equalto', _entity_norm) | list }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _resume_latest: "{{ (_resume_candidates | sort(attribute='created_at'))[-1] if _resume_candidates|count>0 else none }}"
              _id_resolved: >
                {{ _tid_in if _tid_in|length > 0 else (_resume_latest.id if _resume_latest is mapping else '') }}
          - condition: template
            value_template: "{{ _id_resolved|length > 0 }}"
          - action: pyscript.memory_cache_get
            data: { key: "{{ _prefix }}{{ _id_resolved }}" }
            response_variable: _tres
          - variables:
              _tres_data: "{{ _tres.value | default({}) if _tres.status == 'ok' else {} }}"
          - condition: template
            value_template: "{{ _tres.status == 'ok' and (_tres_data.status|string|lower) == 'paused' and (_tres_data.remaining|int) > 0 }}"
          - variables:
              _T: "{{ _tres_data }}"
              _remaining: "{{ _T.remaining|int(0) }}"
              _remaining_safe: "{{ _remaining if _remaining > 0 else 0 }}"
              _new_end_iso: "{{ (now() + timedelta(seconds=_remaining_safe)).isoformat() }}"
              _resumed_at: "{{ now().isoformat() }}"
              _T_running: "{{ dict(_T, **{'status':'running','resumed_at': _resumed_at,'end':_new_end_iso,'remaining': _remaining_safe}) }}"
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id_resolved }}"
              value: >
                {{ _T_running }}
              ttl_seconds: "{{ (_remaining_safe + (_buf|int)) }}"
            response_variable: cache_set_timer_id
          - variables:
              _T: "{{ _T_running }}"
          - wait_for_trigger:
              - trigger: template
                value_template: "{{ now() >= as_datetime(_new_end_iso) }}"
              - trigger: event
                event_type: device_timer_signal
                event_data: { timer_id: "{{ _id_resolved }}" }
            timeout: "{{ (as_datetime(_new_end_iso) - now()).total_seconds()|int + 5 }}"
            continue_on_timeout: true
          - choose:
              - conditions: "{{ wait.trigger and wait.trigger.trigger == 'event' and (wait.trigger.event.data.reason | default('cancel') | lower) == 'pause' }}"
                sequence:
                  - stop: "paused_on_resume"
              - conditions: "{{ wait.trigger and wait.trigger.trigger == 'event' }}"
                sequence:
                  - variables:
                      _IDX_RESUME: "{{ _IDX_ALIVE }}"
                  - action: pyscript.memory_cache_get
                    data: { key: "{{ _index_key }}" }
                    response_variable: _idx_resume_cancel
                  - variables:
                      _IDX_RESUME_CURRENT: >
                        {% set idx_raw = _idx_resume_cancel.value if _idx_resume_cancel.status == 'ok' else [] %}
                        {% if idx_raw is sequence %}
                          {{ idx_raw }}
                        {% else %}
                          {{ [] }}
                        {% endif %}
                      _IDX_RESUME2: >
                        {% set ns = namespace(out=[]) %}
                        {% set resume_current = _IDX_RESUME_CURRENT if _IDX_RESUME_CURRENT is sequence else [] %}
                        {% for existing in resume_current %}
                          {% if existing != _id_resolved and existing not in ns.out %}
                            {% set ns.out = ns.out + [existing] %}
                          {% endif %}
                        {% endfor %}
                        {% set resume = _IDX_RESUME if _IDX_RESUME is sequence else [] %}
                        {% for existing in resume %}
                          {% if existing != _id_resolved and existing not in ns.out %}
                            {% set ns.out = ns.out + [existing] %}
                          {% endif %}
                        {% endfor %}
                        {{ ns.out }}
                      _IDX_ALIVE: "{{ _IDX_RESUME2 if _IDX_RESUME2 is sequence else [] }}"
                  - action: pyscript.memory_cache_set
                    data:
                      key: "{{ _index_key }}"
                      value: "{{ _IDX_RESUME2 if _IDX_RESUME2 is sequence else [] }}"
                      ttl_seconds: 2592000
                    response_variable: cache_set_index
                  - action: pyscript.memory_cache_set
                    data:
                      key: "{{ _prefix }}{{ _id_resolved }}"
                      value: >
                        {{ dict(_T, **{'status':'canceled','canceled_at': now().isoformat(),'remaining':0}) }}
                      ttl_seconds: "{{ _buf|int }}"
                    response_variable: cache_set_timer_id
                  - stop: "canceled_on_resume"
          # Expired on resume - run stored action
          - variables:
              _resume_actions: "{{ (_T.actions | default([])) | selectattr('action','defined') | list }}"
          - choose:
              - conditions: "{{ _resume_actions | count > 0 }}"
                sequence:
                  - repeat:
                      for_each: "{{ _resume_actions }}"
                      sequence:
                        - action: "{{ repeat.item.action }}"
                          target: "{{ repeat.item.target | default({}) }}"
                          data: "{{ repeat.item.data | default({}) }}"
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _prefix }}{{ _id_resolved }}"
              value: >
                {{ dict(_T, **{'status':'expired','expired_at': now().isoformat(),'end': _new_end_iso,'remaining':0}) }}
              ttl_seconds: "{{ _buf|int }}"
            response_variable: cache_set_timer_id
          # Remove from index
          - action: pyscript.memory_cache_get
            data: { key: "{{ _index_key }}" }
            response_variable: _idx2
          - variables:
              __IDX: >
                {% set idx_raw = _idx2.value if _idx2.status == 'ok' else [] %}
                {% if idx_raw is sequence %}
                  {{ idx_raw }}
                {% else %}
                  {{ [] }}
                {% endif %}
              __IDX2: >
                {% set ids = [] %}
                {% for existing in __IDX %}
                  {% if existing != _id_resolved %}
                    {% set ids = ids + [existing] %}
                  {% endif %}
                {% endfor %}
                {{ ids }}
          - action: pyscript.memory_cache_set
            data:
              key: "{{ _index_key }}"
              value: "{{ __IDX2 if __IDX2 is sequence else [] }}"
              ttl_seconds: 2592000
            response_variable: cache_set_index

      #######################################################################
      # LIST (LLM-friendly payload)
      #######################################################################
      - conditions: "{{ _mode == 'list' }}"
        sequence:
          # Compact index again (safety)
          - action: pyscript.memory_cache_get
            data: { key: "{{ _index_key }}" }
            response_variable: _idx3
          - variables:
              _IDS: >
                {% set ids_raw = _idx3.value if _idx3.status == 'ok' else [] %}
                {% if ids_raw is sequence %}
                  {{ ids_raw }}
                {% else %}
                  {{ [] }}
                {% endif %}
              _IDS_COUNT: "{{ _IDS | length if _IDS is sequence else 0 }}"
              _ALIVE: []
          - repeat:
              for_each: "{{ _IDS if _IDS is sequence else [] }}"
              sequence:
                - action: pyscript.memory_cache_get
                  data: { key: "{{ _prefix }}{{ repeat.item }}" }
                  response_variable: _lr
                - variables:
                    _lr_data: "{{ _lr.value | default({}) if _lr.status == 'ok' else {} }}"
                - choose:
                    - conditions: "{{ _lr.status == 'ok' }}"
                      sequence:
                        - variables:
                            _ALIVE: >
                              {% set current = (_ALIVE | list) if _ALIVE is sequence else [] %}
                              {{ current + [_lr_data] }}
          - variables:
              _filter_norm: "{{ (_filter|string)|lower }}"
              _ACTIVE_LIST: >
                {% set alive = _ALIVE if _ALIVE is sequence else [] %}
                {% set ns = namespace(items=[]) %}
                {% for t in alive %}
                  {% set st = (t['status'] | default('') | string | lower) %}
                  {% set entity_raw = t['entity_id'] | default('') %}
                  {% set entity_id = entity_raw|string %}
                  {% set entity_norm = entity_id|lower %}
                  {% if st in ['running','paused'] and (_filter_norm|length==0 or entity_norm==_filter_norm) %}
                    {% if st == 'running' %}
                      {% set remain_calc = (as_timestamp(as_datetime(t['end'] | default(now()))) - as_timestamp(now())) | int(0) %}
                    {% else %}
                      {% set remain_calc = t['remaining'] | default(0) | int %}
                    {% endif %}
                    {% if remain_calc < 0 %}
                      {% set remain_calc = 0 %}
                    {% endif %}
                    {% set ns.items = ns.items + [dict(
                      id=t['id'],
                      entity_id=entity_id,
                      status=st,
                      end=t['end'],
                      remaining=remain_calc,
                      created_at=t['created_at'] | default(''),
                      actions=t['actions'] | default([])
                    )] %}
                  {% endif %}
                {% endfor %}
                {{ ns.items | sort(attribute='created_at') | reverse | list }}
              _count: "{{ _ACTIVE_LIST | length if _ACTIVE_LIST is sequence else 0 }}"
          - variables:
              _summary: >
                {% if _count == 0 %}
                  No active timers {{ "matching entity " ~ _filter if _filter_norm|length>0 else "right now" }}.
                {% else %}
                  {{ "There " ~ ("is" if _count==1 else "are") ~ " " ~ _count ~ " active timer" ~ ("" if _count==1 else "s") ~ "." }}
                {% endif %}
              _payload: >
                {{
                  dict(
                    count=_count | int,
                    entity_filter=_filter,
                    timers=(_ACTIVE_LIST if _ACTIVE_LIST is sequence else []),
                    summary=_summary
                  )
                }}
          - stop: ""
            response_variable: _payload
