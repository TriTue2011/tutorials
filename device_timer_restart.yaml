blueprint:
  name: Device Timer Restart Handler
  author: luuquangvu
  description: >-
    # Restore Device Timer timers after restart or script.reload

    - Triggered on `homeassistant_start` and whenever the `script.reload` service runs.

    - Reads the Device Timer cache, resuming timers with remaining time and executing actions for overdue timers.
  domain: automation
  input:
    required_settings:
      name: Required settings
      icon: mdi:script-text
      description: Select the Device Timer script entity to resume timers for.
      input:
        timer_script:
          name: Device Timer script entity
          description: Script entity created from the Device Timer blueprint
          selector:
            entity:
              filter:
                - domain: script
    advanced_settings:
      name: Advanced settings
      icon: mdi:tools
      description: Optional cache parameters (index key, timer prefix, TTL buffer). Only change if you customized them in Device Timer.
      collapsed: true
      input:
        registry_index_key:
          name: Cache index key
          description: Cache key that stores the full list of timer IDs
          default: voice_timer_index
          selector:
            text:
        registry_timer_prefix:
          name: Per-timer cache key prefix
          description: Prefix prepended to each individual timer key in cache
          default: "voice_timer:"
          selector:
            text:
        ttl_buffer_seconds:
          name: TTL buffer (seconds)
          description: Seconds added to each timer's remaining duration when writing to cache
          default: 120
          selector:
            number:
              min: 60
              max: 3600
              unit_of_measurement: s
              mode: box

mode: queued
max_exceeded: silent

triggers:
  - trigger: homeassistant
    event: start

conditions: []

actions:
  - variables:
      _index_key: !input registry_index_key
      _prefix: !input registry_timer_prefix
      _buf: !input ttl_buffer_seconds
      _script_entity: !input timer_script
      _ids_to_remove: []

  - action: pyscript.memory_cache_get
    data:
      key: "{{ _index_key }}"
    response_variable: _idx_res

  - variables:
      _timer_ids: >
        {% set raw = _idx_res.value if _idx_res.status == 'ok' else [] %}
        {% if raw is sequence %}
          {{ raw }}
        {% else %}
          {{ [] }}
        {% endif %}

  - repeat:
      for_each: "{{ _timer_ids if _timer_ids is sequence else [] }}"
      sequence:
        - action: pyscript.memory_cache_get
          data:
            key: "{{ _prefix }}{{ repeat.item }}"
          response_variable: _timer_res

        - variables:
            _timer_data: "{{ _timer_res.value | default({}) if _timer_res.status == 'ok' else {} }}"
            _status: "{{ _timer_data.status | default('') | string | lower }}"

        - choose:
            - conditions: "{{ _timer_res.status == 'ok' and _status == 'running' }}"
              sequence:
                - variables:
                    _end_iso: "{{ _timer_data.end | default('') }}"
                    _end_dt: "{{ as_datetime(_end_iso) if _end_iso | length > 0 else now() }}"
                    _remaining: "{{ (as_timestamp(_end_dt) - as_timestamp(now())) | int }}"

                - choose:
                    - conditions: "{{ _remaining > 0 }}"
                      sequence:
                        - variables:
                            _paused_payload: >
                              {{
                                dict(
                                  _timer_data,
                                  **{
                                    'status': 'paused',
                                    'paused_at': now().isoformat(),
                                    'remaining': _remaining
                                  }
                                )
                              }}
                            _ttl_seconds: "{{ (_remaining | int) + (_buf | int) }}"

                        - action: pyscript.memory_cache_set
                          data:
                            key: "{{ _prefix }}{{ repeat.item }}"
                            value: "{{ _paused_payload }}"
                            ttl_seconds: "{{ _ttl_seconds }}"
                          response_variable: cache_set_timer_id

                        - choose:
                            - conditions: "{{ _script_entity | length > 0 }}"
                              sequence:
                                - service: script.turn_on
                                  target:
                                    entity_id: "{{ _script_entity }}"
                                  data:
                                    variables:
                                      mode: resume
                                      timer_id: "{{ repeat.item }}"
                                      target_entity: "{{ _timer_data.entity_id | default('') }}"

                  default:
                    - variables:
                        _actions_list: >
                          {% set raw = _timer_data.actions | default([]) %}
                          {% if raw is sequence %}
                            {{ raw }}
                          {% else %}
                            {{ [] }}
                          {% endif %}

                    - choose:
                        - conditions: "{{ _actions_list | count > 0 }}"
                          sequence:
                            - repeat:
                                for_each: "{{ _actions_list }}"
                                sequence:
                                  - choose:
                                      - conditions: "{{ repeat.item.action is defined and repeat.item.action | string | length > 0 }}"
                                        sequence:
                                          - service: "{{ repeat.item.action }}"
                                            target: "{{ repeat.item.target | default({}) }}"
                                            data: "{{ repeat.item.data | default({}) }}"

                    - variables:
                        _expired_payload: >
                          {{
                            dict(
                              _timer_data,
                              **{
                                'status': 'expired',
                                'expired_at': now().isoformat(),
                                'remaining': 0
                              }
                            )
                          }}

                    - action: pyscript.memory_cache_set
                      data:
                        key: "{{ _prefix }}{{ repeat.item }}"
                        value: "{{ _expired_payload }}"
                        ttl_seconds: "{{ _buf }}"
                      response_variable: cache_set_timer_id

                    - variables:
                        _ids_to_remove: >
                          {% set current = _ids_to_remove if _ids_to_remove is sequence else [] %}
                          {{ current + [repeat.item] }}

  - variables:
      _updated_index: >
        {% set original = _timer_ids if _timer_ids is sequence else [] %}
        {% set remove = _ids_to_remove if _ids_to_remove is sequence else [] %}
        {% set ns = namespace(out=[]) %}
        {% for item in original %}
          {% if item not in remove %}
            {% set ns.out = ns.out + [item] %}
          {% endif %}
        {% endfor %}
        {{ ns.out }}

  - action: pyscript.memory_cache_set
    data:
      key: "{{ _index_key }}"
      value: "{{ _updated_index }}"
      ttl_seconds: 2592000
    response_variable: cache_set_index
